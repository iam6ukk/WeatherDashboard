var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IgcDialogComponent_1;
import { html, LitElement, nothing } from 'lit';
import { property, query, state } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { AnimationPlayer } from '../../animations/player.js';
import { fadeIn, fadeOut } from '../../animations/presets/fade/index.js';
import { themes } from '../../theming/theming-decorator.js';
import IgcButtonComponent from '../button/button.js';
import { blazorAdditionalDependencies } from '../common/decorators/blazorAdditionalDependencies.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { createCounter, partNameMap } from '../common/util.js';
import { styles } from './themes/light/dialog.base.css.js';
import { styles as bootstrap } from './themes/light/dialog.bootstrap.css.js';
import { styles as fluent } from './themes/light/dialog.fluent.css.js';
import { styles as indigo } from './themes/light/dialog.indigo.css.js';
import { styles as material } from './themes/light/dialog.material.css.js';
let IgcDialogComponent = IgcDialogComponent_1 = class IgcDialogComponent extends EventEmitterMixin(LitElement) {
    constructor() {
        super(...arguments);
        this.titleId = `title-${IgcDialogComponent_1.increment()}`;
        this.keepOpenOnEscape = false;
        this.closeOnOutsideClick = false;
        this.hideDefaultAction = false;
        this.open = false;
        this.animating = false;
        this.formSubmitHandler = (e) => {
            var _a;
            if (e instanceof SubmitEvent && e.submitter) {
                this.returnValue = ((_a = e.submitter) === null || _a === void 0 ? void 0 : _a.value) || '';
            }
            if (!e.defaultPrevented) {
                this.hideWithEvent();
            }
        };
    }
    static register() {
        registerComponent(this, IgcButtonComponent);
    }
    set closeOnEscape(value) {
        this.keepOpenOnEscape = !value;
    }
    get closeOnEscape() {
        return !this.keepOpenOnEscape;
    }
    handleOpenState() {
        this.open ? this.dialog.showModal() : this.dialog.close();
    }
    async firstUpdated() {
        this.animationPlayer = new AnimationPlayer(this.dialog);
        await this.updateComplete;
        if (this.open) {
            this.dialog.showModal();
        }
    }
    async toggleAnimation(dir) {
        const animation = dir === 'open' ? fadeIn : fadeOut;
        const [_, event] = await Promise.all([
            this.animationPlayer.stopAll(),
            this.animationPlayer.play(animation()),
        ]);
        return event.type === 'finish';
    }
    show() {
        if (this.open) {
            return;
        }
        this.toggleAnimation('open');
        this.open = true;
    }
    async hide() {
        if (!this.open) {
            return;
        }
        this.animating = true;
        if (await this.toggleAnimation('close')) {
            this.animating = false;
            this.open = false;
        }
    }
    toggle() {
        this.open ? this.hide() : this.show();
    }
    async hideWithEvent() {
        if (!this.open) {
            return;
        }
        if (!this.handleClosing()) {
            return;
        }
        this.animating = true;
        if (await this.toggleAnimation('close')) {
            this.open = false;
            this.animating = false;
            this.emitEvent('igcClosed');
        }
        await this.updateComplete;
    }
    handleCancel(event) {
        event.preventDefault();
        if (!this.keepOpenOnEscape) {
            this.hideWithEvent();
        }
    }
    handleClick({ clientX, clientY, target }) {
        if (this.closeOnOutsideClick && this.dialog.isSameNode(target)) {
            const { left, top, right, bottom } = this.dialog.getBoundingClientRect();
            const between = (x, low, high) => x >= low && x <= high;
            if (!(between(clientX, left, right) && between(clientY, top, bottom))) {
                this.hideWithEvent();
            }
        }
    }
    handleClosing() {
        return this.emitEvent('igcClosing', { cancelable: true });
    }
    handleSlotChange() {
        Array.from(this.querySelectorAll('igc-form, form'))
            .filter((each) => each.getAttribute('method') === 'dialog')
            .forEach((form) => {
            const event = /igc-form/i.test(form.tagName) ? 'igcSubmit' : 'submit';
            form.removeEventListener(event, this.formSubmitHandler);
            form.addEventListener(event, this.formSubmitHandler);
        });
    }
    render() {
        const label = this.ariaLabel ? this.ariaLabel : undefined;
        const labelledby = label ? undefined : this.titleId;
        const backdropParts = partNameMap({
            backdrop: true,
            animating: this.animating,
        });
        return html `
      <div part=${backdropParts} aria-hidden=${!this.open}></div>
      <dialog
        part="base"
        role="dialog"
        @click=${this.handleClick}
        @cancel=${this.handleCancel}
        aria-label=${ifDefined(label)}
        aria-labelledby=${ifDefined(labelledby)}
      >
        <header part="title" id=${this.titleId}>
          <slot name="title"><span>${this.title}</span></slot>
        </header>
        <section part="content">
          <slot @slotchange=${this.handleSlotChange}></slot>
        </section>
        <footer part="footer">
          <slot name="footer">
            ${this.hideDefaultAction
            ? nothing
            : html `<igc-button variant="flat" @click=${this.hideWithEvent}
                  >OK</igc-button
                >`}
          </slot>
        </footer>
      </dialog>
    `;
    }
};
IgcDialogComponent.tagName = 'igc-dialog';
IgcDialogComponent.styles = [styles];
IgcDialogComponent.increment = createCounter();
__decorate([
    query('dialog', true)
], IgcDialogComponent.prototype, "dialog", void 0);
__decorate([
    property({ type: Boolean, attribute: 'close-on-escape' })
], IgcDialogComponent.prototype, "closeOnEscape", null);
__decorate([
    property({ type: Boolean, attribute: 'keep-open-on-escape' })
], IgcDialogComponent.prototype, "keepOpenOnEscape", void 0);
__decorate([
    property({ type: Boolean, attribute: 'close-on-outside-click' })
], IgcDialogComponent.prototype, "closeOnOutsideClick", void 0);
__decorate([
    property({ type: Boolean, attribute: 'hide-default-action' })
], IgcDialogComponent.prototype, "hideDefaultAction", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], IgcDialogComponent.prototype, "open", void 0);
__decorate([
    state()
], IgcDialogComponent.prototype, "animating", void 0);
__decorate([
    property()
], IgcDialogComponent.prototype, "title", void 0);
__decorate([
    property({ attribute: false })
], IgcDialogComponent.prototype, "returnValue", void 0);
__decorate([
    watch('open', { waitUntilFirstUpdate: true })
], IgcDialogComponent.prototype, "handleOpenState", null);
IgcDialogComponent = IgcDialogComponent_1 = __decorate([
    themes({
        light: { bootstrap, material, fluent, indigo },
        dark: { bootstrap, material, fluent, indigo },
    }),
    blazorAdditionalDependencies('IgcButtonComponent')
], IgcDialogComponent);
export default IgcDialogComponent;
//# sourceMappingURL=dialog.js.map