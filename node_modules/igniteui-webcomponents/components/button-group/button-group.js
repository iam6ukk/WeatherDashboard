var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { LitElement, html } from 'lit';
import { property, queryAssignedElements } from 'lit/decorators.js';
import { themes } from '../../theming/theming-decorator.js';
import { styles } from '../button-group/themes/light/button-group.base.css.js';
import { styles as bootstrap } from '../button-group/themes/light/button-group.bootstrap.css.js';
import { styles as fluent } from '../button-group/themes/light/button-group.fluent.css.js';
import { styles as indigo } from '../button-group/themes/light/button-group.indigo.css.js';
import { styles as material } from '../button-group/themes/light/button-group.material.css.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import IgcToggleButtonComponent from './toggle-button.js';
let IgcButtonGroupComponent = class IgcButtonGroupComponent extends EventEmitterMixin(LitElement) {
    constructor() {
        super(...arguments);
        this._selectedItems = new Set();
        this.mutationObserver = this.setMutationsObserver();
        this.observerConfig = {
            attributeFilter: ['selected'],
            childList: true,
            subtree: true,
        };
        this.disabled = false;
        this.alignment = 'horizontal';
        this.selection = 'single';
    }
    static register() {
        registerComponent(this, IgcToggleButtonComponent);
    }
    get _selectedButtons() {
        return this.toggleButtons.filter((b) => b.selected);
    }
    get selectedItems() {
        return this._selectedButtons.map((b) => b.value).filter((v) => v);
    }
    set selectedItems(values) {
        if (values && values.length) {
            this._selectedItems = new Set(values);
            this.setSelection(this._selectedItems);
        }
    }
    updateDisabledState() {
        this.toggleButtons.forEach((b) => (b.disabled = this.disabled));
    }
    updateSelectionState() {
        if (this._selectedButtons.length) {
            this.toggleButtons.forEach((b) => (b.selected = false));
        }
    }
    connectedCallback() {
        super.connectedCallback();
        this.mutationObserver.observe(this, this.observerConfig);
    }
    disconnectedCallback() {
        this.mutationObserver.disconnect();
        super.disconnectedCallback();
    }
    firstUpdated() {
        if (this.disabled) {
            this.updateDisabledState();
        }
        const buttons = this._selectedButtons;
        if (buttons.length) {
            if (this.selection !== 'multiple') {
                const index = buttons.indexOf(buttons.at(-1));
                for (let i = 0; i < index; i++) {
                    buttons[i].selected = false;
                }
            }
        }
        else {
            this.setSelection(this._selectedItems);
        }
    }
    handleClick(event) {
        const button = event
            .composedPath()
            .find((element) => element instanceof IgcToggleButtonComponent);
        if (button) {
            this.selection === 'multiple'
                ? this.handleMultipleSelection(button)
                : this.handleSingleSelection(button);
        }
    }
    handleSingleSelection(button) {
        const singleRequired = this.selection === 'single-required';
        const selectedButton = this._selectedButtons.at(0);
        const isSame = selectedButton && selectedButton.value === button.value;
        if (selectedButton) {
            if (singleRequired && isSame)
                return;
            this.emitDeselectEvent(selectedButton);
        }
        if (isSame)
            return;
        this.emitSelectEvent(button);
    }
    handleMultipleSelection(button) {
        button.selected
            ? this.emitDeselectEvent(button)
            : this.emitSelectEvent(button);
    }
    emitSelectEvent(button) {
        const select = this.emitEvent('igcSelect', {
            cancelable: true,
            detail: button.value,
        });
        if (select) {
            button.selected = true;
        }
    }
    emitDeselectEvent(button) {
        const deselect = this.emitEvent('igcDeselect', {
            cancelable: true,
            detail: button.value,
        });
        if (deselect) {
            button.selected = false;
        }
    }
    setSelection(values) {
        for (const button of this.toggleButtons) {
            if (values.has(button.value)) {
                button.selected = true;
                if (this.selection !== 'multiple') {
                    break;
                }
            }
        }
    }
    setMutationsObserver() {
        return new MutationObserver((records, observer) => {
            var _a;
            observer.disconnect();
            if (this.selection !== 'multiple' && this._selectedButtons.length > 1) {
                const added = this.getAddedButtons(records);
                const button = added.buttons.length
                    ? added.buttons.at(-1)
                    : (_a = records.at(-1)) === null || _a === void 0 ? void 0 : _a.target;
                const index = this.toggleButtons.indexOf(button);
                this.toggleButtons.forEach((b, i) => {
                    if (b.selected && i !== index) {
                        b.selected = false;
                    }
                });
            }
            observer.observe(this, this.observerConfig);
        });
    }
    getAddedButtons(records) {
        const added = { buttons: [] };
        records
            .filter((x) => x.type === 'childList')
            .reduce((prev, curr) => {
            prev.buttons = prev.buttons.concat(Array.from(curr.addedNodes).map((node) => node));
            return prev;
        }, added);
        return added;
    }
    render() {
        return html `
      <div
        part="group"
        role="group"
        aria-disabled=${this.disabled}
        @click=${this.handleClick}
      >
        <slot></slot>
      </div>
    `;
    }
};
IgcButtonGroupComponent.tagName = 'igc-button-group';
IgcButtonGroupComponent.styles = styles;
__decorate([
    queryAssignedElements({ selector: 'igc-toggle-button' })
], IgcButtonGroupComponent.prototype, "toggleButtons", void 0);
__decorate([
    property({ type: Boolean, reflect: true })
], IgcButtonGroupComponent.prototype, "disabled", void 0);
__decorate([
    property({ reflect: true })
], IgcButtonGroupComponent.prototype, "alignment", void 0);
__decorate([
    property({ reflect: false })
], IgcButtonGroupComponent.prototype, "selection", void 0);
__decorate([
    property({ attribute: 'selected-items', type: Array, reflect: false })
], IgcButtonGroupComponent.prototype, "selectedItems", null);
__decorate([
    watch('disabled', { waitUntilFirstUpdate: true })
], IgcButtonGroupComponent.prototype, "updateDisabledState", null);
__decorate([
    watch('selection', { waitUntilFirstUpdate: true })
], IgcButtonGroupComponent.prototype, "updateSelectionState", null);
IgcButtonGroupComponent = __decorate([
    themes({
        light: { bootstrap, material, fluent, indigo },
        dark: { bootstrap, material, fluent, indigo },
    })
], IgcButtonGroupComponent);
export default IgcButtonGroupComponent;
//# sourceMappingURL=button-group.js.map